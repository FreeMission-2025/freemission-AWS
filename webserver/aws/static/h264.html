<script>
    const ws = new WebSocket('ws://localhost:80/ws_h264_stream');
    
    // Important: expect binary data
    ws.binaryType = "arraybuffer";
    
    ws.onopen = () => {
        console.log("WebSocket connected.");
        ws.send("READY");  // Notify server we're ready
    };
    
    ws.onmessage = async (event) => {
        const arrayBuffer = event.data;  // Already ArrayBuffer because binaryType
    
        // Convert to Uint8Array for processing
        const rawFrame = new Uint8Array(arrayBuffer);    
        // Now you can feed rawFrame to your WebCodecs decoder, for example:
    
        if (!window.decoder) {
            window.decoder = new VideoDecoder({
                output: frame => drawFrame(frame),
                error: e => console.error("Decoder error:", e)
            });
            
            await window.decoder.configure({
                codec: 'avc1.42E01E', // baseline profile H264
                hardwareAcceleration: 'prefer-hardware'
            });
        }
    
        // Decode the H264 raw frame
        try {
            window.decoder.decode(new EncodedVideoChunk({
                type: "key",  // if you know it's keyframe (I can help auto-detect later)
                timestamp: performance.now() * 1000,  // microseconds
                data: rawFrame
            }));
        } catch (e) {
            console.error("Decode failed:", e);
        }
    };
    
    // Helper to draw frames to canvas
    function drawFrame(frame) {
        const canvas = document.getElementById("videoCanvas");
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
    
        const bitmap = frame;
        createImageBitmap(bitmap).then((bmp) => {
            canvas.width = bmp.width;
            canvas.height = bmp.height;
            ctx.drawImage(bmp, 0, 0);
            frame.close();
        });
    }
    </script>
    
    <canvas id="videoCanvas" style="border: 1px solid white;"></canvas>
    